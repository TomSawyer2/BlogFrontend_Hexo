---
title: JS十五种设计模式
date: 2022-01-20 13:20:00
categories:
- JavaScript
- 学习笔记
tags:
- JavaScript
- 学习笔记
---

# JavaScript 十五种设计模式

## 设计原则

单一职责原则（SRP）：一个对象与方法只干一件事；
最小知识原则（LKP）：解耦对象，引入第三方以减少对象之间的联系；
开放-封闭原则（OCP）：类、模块、函数应可拓展，但不可修改。

## 设计模式

### 单例模式

**定义**： 一个类只有一个实例，并提供一个全局访问点。
**核心**： 一个实例，全局访问。
**实现**： 可以通过抽象化单例的名称，从而只需要复写访问的方法即可实现单例的复用。

### 策略模式

**定义**： 定义一系列算法，分别封装起来，并使其可以互相替换。
**核心**： 策略类（实现具体算法）+环境类（接受客户请求并委托给策略类）。
**实现**： 客户调用环境类，环境类通过参数判断需要调用的策略类，并将请求传递，最终返回客户。
**用途**： 表单校验。
**优缺点**： 避免多重条件语句，封装后利于维护，但是需要事先定义所有情况。

### 代理模式

**定义**： 为一个对象提供代用品或者占位符，控制对它的访问。
**核心**： 客户将请求先交给代理，代理进行一定处理后再把请求给本体对象。
**实现**： 保护代理、虚拟代理、缓存代理。
保护代理：限制访问主体的一些行为，比如不满足要求就直接 return。
虚拟代理：对访问主体的行为进行一些处理，比如加入节流等等。
缓存代理：对访问主体的行为提供缓存。

### 迭代器模式

**定义**： 提供一种方法顺序访问一个聚合对象中的各个元素，不暴露对象的内部表示。
**核心**： 不需要了解对象内部构造也可以按序访问其中每个元素。
**实现**： map、forEach。

### 发布-订阅模式

也叫观察者模式。
**定义**： 对象间一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象也会得到通知。
**核心**： 传统方式将订阅者自身作为引用传入发布者，JS 中使用注册回调函数的方式订阅。
**实现**： 事件，`addEventListener`是订阅，执行操作是发布。
**优缺点**： 时间、对象间解耦，可用于框架与异步编程，但会使数据长时间在内存中停留，有性能问题，同时弱化对象间的联系，不易维护。

### 命令模式

**定义**： 使用松耦合方式设计程序，使请求发送者与接收者之间解耦。
**核心**： 接收者提供 execute、undo、redo 等等方法。
**实现**： 接收者暴露方法供发送者调用。
**用途**： 执行、撤销、重做、简单的宏命令。

### 组合模式

**定义**： 使用小对象构建大对象。
**核心**： 调用组合对象的 execute 方法，会递归调用子对象的 execute 方法。
**实现**： 对于文件夹和具体文件，定义文件夹为组合对象，文件为叶对象，构建树形结构后即可通过组合对象对整棵树进行操作。
**优缺点**： 用树可以方便地表示对象的部分-整体结构，且可以方便地对整棵树进行指定操作，但代码可读性较差，性能也有影响。

### 模板方法模式

**定义**： 抽象父类+具体的实现子类。
**核心**： 在父类中封装子类的算法框架，init 方法作为算法的模板，指导子类按照某种顺序执行方法。
**实现**： 主要方式为继承，通用方法放父类，特殊方法放子类，重写父类的方法，最终子类直接调用父类的模板函数执行。

### 享元模式

**定义**： 尽量减少共享对象的数量，用于性能优化。
**核心**： 把对象的属性分为内部状态和外部状态，内部状态用于对象的共享，通常不变，外部状态剥离开来，由具体的场景决定。
**实现**： 有大量相似对象的时候可以减少对象的数量，使用工厂创建可共享的对象，使用管理器管理非共享的部分。
注意：没有内部状态时没有参数的工厂对象接近单例模式。

### 职责链模式

**定义**： 多个对象都有机会处理请求，将这些对象连成一条链后沿着链传递请求，直到有一个对象处理它。
**核心**： 发送者只需要直到链的第一个节点，从而使增/删节点变得方便。
**实现**： 通过链一层层传递可以减少 if 的数量。
**优缺点**： 减少 if，但会影响性能。

### 中介者模式

**定义**： 所有有联系的对象都通过中介者对象通信，发生改变时只需要通知中介者对象。
**核心**： 多对多->一对多。
**实现**： 将数据处理过程封装成中介者，需要处理时通知中介者即可。

### 装饰者模式

**定义**： 动态地给某个对象添加一些额外的方法，不影响原来派生的其他对象。
**核心**： 动态给对象添加方法，可形成装饰链。
**实现**： 重写对象的属性。

### 状态模式

**定义**： 事物内部状态改变后将委托交给状态对象，再渲染自己的行为。
**核心**： 把事物每种状态都封装成单独的类，与该状态有关的行为都封装在该类内部。
**实现**： 每种状态都有单独的类来描述，状态发生改变后调用对应类即可。
**优缺点**： 状态切换逻辑由状态类控制，易于维护，但性能较差。可以使用享元模式把逻辑分离在状态类中，但不易看懂逻辑。

### 适配器模式

**定义**： 对接口不兼容的部分进行适配。
**核心**： 解决接口间不匹配的问题。
**实现**： 相当于加个中间件，把前者的出参转换为后者的入参。

### 外观模式

**定义**： 为子系统的一组接口提供一个一致的界面，定义一个高层接口，使子系统更加容易使用。
**核心**： 可以用高层接口访问子系统，也可以直接访问子系统。
**实现**： 把子系统的接口统一起来，提供一个外部访问接口即可。

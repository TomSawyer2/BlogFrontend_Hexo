---
title: 数模算法
date: 2022-02-01 13:20:00
categories:
- Matlab
- 算法
- 学习笔记
tags:
- Matlab
- 算法
- 学习笔记
---

# 数模算法

## 线性规划

### 定义

有限条件，最大收益

决策变量、目标函数、约束条件

即在一组线性约束条件下求线性目标函数的最大/小值，且所有变量都是一次方

**适用**：生产安排、投资收益、销售运输、车辆安排

**注意**：整数规划、0-1 规划是特例

### Matlab 求解

模型转换为标准型：目标函数最小值、约束条件 ≤ 或者=
求 y 最大值<=>求-y 最小值

```matlab
[x, fval] = linprog(f, A, b, Aeq, beq, lb, ub)
% f 目标函数系数列向量
% A b 不等式约束条件的变量系数矩阵和常数项矩阵，不存在用[]代替
% Aeq beq 等式约束条件的系数矩阵和常数项矩阵，不存在用[]代替
% lb ub 决策变量的最小取值和最大取值
% x 最优解的变量取值
% fval 目标函数最优值
% 没有等式约束和最小最大取值的约束时Aeq beq lb ub都可以不写
% 求完之后需要y = -fval
```

## 非线性规划

### 定义

有限条件，最大收益

至少一个变量不是一次方

**适用**：投资规划（最佳投资方案->收益率）、角度调整、生产安排

### Matlab 求解

```matlab
[x, fval] = fmincon(fun, x0, A, b, Aeq, beq, lb, ub, nonlcon)
% fun 单独函数文件里定义的目标函数
% x0 决策变量的初始值，个数不清楚可以随便写
% A b 线性约束的不等式变量系数矩阵和常数项矩阵，都是≤
% Aeq beq 线性约束的等式变量系数矩阵和常数项矩阵
% lb ub 决策变量的最小取值和最大取值
% nonlcon 非线性约束，包括不等式和等式，函数需要根据有几个约束写几个出参
```

函数文件

```matlab
% fun1.m
function f = fun1(x)
f = sum(x .^ 2) + 8
```

## 多目标规划

### 定义

多个条件，多个目标

不超过->尽量 ≤；充分利用->尽量=；不少于->尽量 ≥

**注意**：不同目标的重要性是主观上区分的，但应该使整体的效果好

### 概念

#### 正负偏差变量

正偏差变量 d3+表示实际值超过目标值的部分，值都是正的
负偏差变量 d3-表示实际值未达到目标值的部分，值都是正的
d30 表示目标值

不少于->负偏差变量 d3-越小越好

#### 绝对约束和目标约束

绝对约束是模型自带的，必须满足，不然解不成立
目标约束是模型对不等式右侧追求的值可以有偏差，即可以加入正负偏差变量
即 8x1 + 10x2 ≥ 56 可以变为 8x1 + 10x2 + di- - di+ = 56

#### 优先因子

优先因子 PK 越大，即优先级越高，一般找文献确定优先因子的比例

不超过目标值->d1+越小越好->目标函数 min P1d1+
恰好达到目标值->正负偏差都尽量小->目标函数 min P2(d2-+d2+)
不少于目标值->d3-越小越好->min P3d3+

### Matlab 求解

把所有目标约束都加上 di- - di+变成等式，再主观确定优先因子
目标函数即为所有目标按上述要求乘以优先因子后相加，绝对约束不变，目标约束均为等式
之后使用 fgoalattain 或者序贯算法或者 Lingo 求解

## 最短路径

### 定义

从 A 到 B，总路径最短
即为从图的某个顶点出发，到达另外一个顶点的所经过的边的权重之和最小的一条路径

常见算法：Dijkstra 算法、graphshortestpath 函数

### Matlab 求解

```matlab
[dist, path, pred] = graphshortestpath(DG, 1, 3)
% dist 是最短路径的值
% path是最短路径的节点顺序
% pred是到每一个节点的最短路径的终点前一个节点

point_name = ["城市1", "城市2"]
h = view(biograph(DG, point_name, 'ShowWeights', 'on')
% biograph生成图，view显示这张图
```

注意：DG 是有向图的矩阵表示（邻接矩阵），第一行第一列代表 1->1 的权重，第一行第二列代表 1->2 的权重；第二行第一列代表 2->1 的权重，以此类推

生成 DG 的方法：使用 sparse 生成稀疏矩阵，即除了标明的元素都是 0

```matlab
W = [10, 5, 2]
DG = sparse([1, 1, 2], ... % 这行没写完，下行续上
            [2, 3, 4], W)
% W代表对应边的权值，此处理解为sparse第一个参数和第二个参数共同确定一个点，并使用W标出权值，即(1, 2)权值为10，(1, 3)权值为5，(2, 4)权值为2
```

把输出的图变得更清晰

```matlab
% @params 图 边的出点 边的入点
edges = getedgesbynodeid(h, get(h.Nodes(path), 'ID'));
set(edges, 'LineColor', [1 0 0]) % R G B
set(edges, 'LineWidth', 2)
% 把最短路径的节点和边缘标记为红色并增加线宽
```

## 最小生成树

### 定义

连通图：从一个顶点出发，总能到达图中的任意一个顶点
最小生成树是所有顶点连通且总路径权值之和最小的图，是基于整个图这个整体而不是某个点而言的

### Matlab 求解

```matlab
% 注意不要重复写
s = [1, 1, 2, 4]
t = [2, 3, 4, 5]
weights = [20, 10, 2, 13]
% 生成无向图，s和t代表边，weights代表权值
G = graph(s, t, weights)
% 求出最小生成树，得到的T包含节点和对应边的权值
T = minspantree(G)

% 展示图片
p = plot(G, 'EdgeLabel', G.Edges.Weight, "MarkerSize", 8, 'NodeFontSize', 16,'EdgeFontSize',  xxx)
% 突出节点和边
highlight(p, T, 'EdgeColor', 'red', "LineWidth", 3)
```

### 其他计算方法

#### Kruskal 算法

1. 把图中所有边去掉，留下所有顶点；
2. 从图中取出当前权值最小的边，如果放进顶点新图中不形成回路则加入，反之舍弃；
3. 一直重复 2，知道出现 n - 1（n 为顶点数）条边。

**注意**：如果 2 中有两条边权值相同随便选，因此最小生成树可能不唯一，但权值之和相同

这种算法适合点多边少的图

#### Prim 算法

1. 设置一个新图，把原图任意一个顶点取出加入新图；
2. 找一条权值最小的新边加入新图；
3. 重复 2 直到新图中包含所有顶点。

**注意**：若 2 中有两条边权值相同随便选，因此最小生成树可能不唯一，但权值之和相同

适合边多点少的图

## 灰色预测模型-GM(1, 1)模型

### 定义

灰色模型一阶方程一个变量

**适合**：数据少，看不出明显规律

### Matlab 求解

#### 模型计算开始前检验

级比检验 λ(k) = 前一个真实值 / 后一个真实值，若在区间(exp(-2/n+1), exp(2/n+2))内则可使用
_如果在区间外可以尝试平移变换，给每个数据加上任意常数 c 看看能不能用，用完再减 c_

#### 计算

累加生成序列：x(1)(k) = Σ(1->k)x(0)(i)
均值生成序列：x(1)(t)修正为 z(1)(t)，即取前后两个值的均值，z(1)(t) = 0.5x(1)(t) + 0.5x(1)(t - 1) t = 2, ..., n

若均值生成序列类似于一个指数曲线则可构建一阶常微分方程来拟合曲线，最终式子左边是已知数据，右边是含有未知数的函数，就可以用最小二乘法使拟合函数求的值与已知数据的平方差最小，方程矩阵形式为 Y = BU， 求解 U 的估计值为 U' = [a, u]T = (BTB)-1BTY

**注意**：预测值需要把均值/累加序列的值两两相减才能得到

#### 模型计算完成后检验

残差检验 ε(k) = (拟合值 - 真实值) / 真实值，其中第一个拟合值就是第一个真实值，需要小于 0.2，还有级比偏差检验等等

## 时间序列-平稳时间序列-AR 模型

### 定义

平稳时间序列：数据的统计特性不随时间平移而变化，即均值和协方差不变

**适合**：长期看数据有固定趋势，且有继承性；短期看数据有波动

### Matlab 求解

#### 模型计算开始前检验

Daniel 检验，看 spearman 相关系数

```matlab
% 给入数据
a = [1, 23, 1
     22, 5, 23]
% 数据处理，A(:)代表从第一个数取到最后一个数，即把原始数据按照时间顺序展开成一个行向量
a = a'; a = a(:); a = a';

% 时间序列的秩：把数据从小到大排序，每个数据的秩就是序号
Rt = tiedrank(a);

% 计算时间t和Rt两者的spearman相关系数和统计变量T
n = length(a); t = 1:n;
Qs = 1 - 6 / (n * (n ^ 2 - 1)) * sum((t - Rt) .^ 2);
T = Qs * sqrt(n - 2) / sqrt(1 - Qs ^ 2);

% 对于spearman相关系数做假设检验，计算上α/2分位数t_0，若t_0≥|T|则序列平稳，可以继续，反之不行,Qs>0说明有上升趋势
t_0 = tinv(0.995, n - 2);
```

构造平稳序列（一阶差分运算）

```matlab
b = diff(a);
[Tb, t_00] = spearman(b)
```

求得的新序列 b 可以通过检验

#### 计算

`AR(p)`自回归模型本质是一个包含未知参数 c1、c2 以及均值为 0 的随机干扰项 εi 的多项式，其中第 t 年的数据可以用前 p 年的数据表达，写作`AR(p)`，p 应该用 AIC 准则求出，当然可以试值之后的检验再取优

```matlab
m = ar(b, p, 'ls'); % b是前面检验通过的序列，p是已确定的常数，ls指最小二乘法
bhat = predict(m, [b'; 0;]); % 利用多项式m进行预测，样本数据需要为列向量
ahat = [a(1), a + bhat']; % 求原始数据前面几个数据的拟合值，并计算后一个数据的预测值
```

#### 模型计算完成后检验

```matlab
delta = abs((ahat(1: end - 1) - a) ./ a); % 计算原始数据预测的相对误差
```

## 神经网络-感知机

### 定义

**模型**：xi 输入层->Σwixi - b 激活函数（综合判断是否达到阈值）->y 输出层

### 求解

**题目类型**：是否->输出为 0/1->激活函数使用阶跃函数/sigmoid 函数

**综合考虑**：线性求和 Σwixi，其中权重 wi，通常查文献决定

**判断标准**：线性求和和阈值的差值作为激活函数的自变量，即 t = Σwixi - b

**注意**：可以直接把阈值作为权重为 b，输入为-1 的变量处理

### 获取准确的权重-学习

**目的**：从已知数据中学得模型用于确定权重 wi

1. 模型初始化，人为设置权重 wi；
2. 搜集大量输入输出的数据作为训练数据集；
3. 把搜集到的数据代入模型求得估计值 y'
4. 把估计值 y'和实际值 y 比较，差别越小越好
5. 若未满足终止条件则优化权重 wi 得到新的 wi，重复 3；

终止条件：估计值和实际值差值小于一定程度

优化方法：将 wi 改为 wi + △wi = wi + η(y - y')xi，η∈(0, 1)，通常设为 0.1，称为学习率，过大容易震荡，过小收敛速度太慢

## 层析分析法-AHP

### 定义

**模型**：方案层（所有可能的结果）->准则层（判断的标准）->目标层（结果）

### 求解

**过程**：评价类问题->确定三层->写出判断矩阵->一致性检验->算数平均法求权重->加权求和得到结果->得出结论

#### 简单粗暴

对每一组数据[a, b, c, d]归一化处理得到[a/(a + b + c + d), b/(a + b + c + d), c/(a + b + c + d), d/(a + b + c + d)]直接相加即可

#### 加权处理

对每一组数据[xi]进行加权处理得到[wixi]并相加

### 获取准确的权重

对指标重要性两两比较，构造判断矩阵，求出权重

#### 构造判断矩阵

| 目标层   | 准则层 1 | 准则层 2 | 准则层 3 |
| -------- | -------- | -------- | -------- |
| 准则层 1 | 1        |          | 1/5      |
| 准则层 2 |          | 1        |          |
| 准则层 3 | 5        |          | 1        |

矩阵元素 aij 的含义：第 i 个指标相对第 j 个指标的重要程度

**注意**：沿对称线两数相乘为 1

1 - 相同重要
3 - 稍微重要
5 - 明显重要
7 - 强烈重要
9 - 极端重要
2 4 6 8 - 中值

#### 一致性检验

两两比较会导致出现不一致现象，因此需要一致性检验

**理想情况**：满足 aij = aik \* akj 且矩阵各行/列成倍数关系=>一致矩阵

实际情况只需要和一致矩阵的差异不大即可

计算一致性比例 CR：CR = CI / RI，其中 CI = (λMAX - n) / (n - 1)， λMAX 为判断矩阵的最大特征值，n 为指标数（即判断矩阵行数）；其中 RI 为平均随机一致性指标，可查表得到

| n   | 1   | 2   | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| RI  | 0   | 0   | 0.52 | 0.89 | 1.12 | 1.26 | 1.36 | 1.41 | 1.46 | 1.49 |

CR = 0=>一致矩阵， CR < 0.1=>差异不大，通过一致性检验

#### 算数平均法求权重

将判断矩阵按列归一化，即每一行分别求和，结果再除以 n，得到的列向量就是权重向量

注意：上述的判断矩阵是准则层相对于目标层的判断矩阵，如果准则层没有客观数据，则需要通过构造准则层因素个数的判断矩阵来求出每一个方案层元素的权重即评分，之后再进行准则层到目标层的操作，即先构造方案层相对于准则层的判断矩阵

## 动态规划

### 定义

将多阶段决策问题转换为一系列单过程决策问题进行求解，每个过程都做出决策，全部过程的决策形成一个决策序列

**阶段**：对整个过程的划分

**状态**：每个阶段开始时所处的自然状况

**决策**：从现阶段到下阶段的选择手段

**策略**：决策组成的序列

**状态转移方程**：下阶段状态 = f(现阶段状态, 决策)

**指标函数**：衡量过程优劣的数量指标，是关于策略的数量函数

**最优值函数**：实现最优过程的函数

**最优策略**：使指标函数达到最优值的策略

**最优轨线**：经过最优策略经历的状态序列

### 求解

算法题常见的状态转移方程：`dp[i] = dp[i - 1] + dp[i - 2]`

1. 划分阶段；
2. 选择状态；
3. 确定决策、写出状态转移方程；
4. 写出规划方程与边界状态。

## 分治算法

### 定义

将一个大规模问题拆分为小规模问题，且小问题间互相独立，与大问题形式相同，递归解决小问题，将解合并即可得原问题的解

**适用**：问题规模缩小后容易求解，可以分解为规模较小的若干问题，小问题的解合并即为大问题的解，小问题间相互独立

### 求解

1. 将原问题分解为小问题；
2. 若小问题容易求解则直接求解，反之递归地求解各个小问题；
3. 将各个小问题的解合并为原问题的解。

**注意**：一般将大问题分解为大小相等的 2 个问题即可，此处即用到二分

## 概率算法

### 定义

算法在执行的过程中随机选择下一个计算步骤，从而实现比最优选择省时的效果

**分类**：

数值概率算法、蒙特卡罗算法、拉斯维加斯算法、舍伍德算法

数值概率算法：用于数值问题的求解，得到近似解，且精度随计算时间增加不断提高

蒙特卡罗算法：用于求准确解，时间越长准确性越高

拉斯维加斯算法：不会得到不正确的解，但可能算不出解

舍伍德算法：总能算出一个正确的解

### 求解

#### 数值概率算法

使用 random 函数生成随机数后进行计算

#### 舍伍德算法

随机选择一个数组元素作为划分标准，从而降低序列排列情况对算法时间复杂度的影响，当然也可以仅对输入进行随机排序

## 模拟退火算法

### 定义

由初始解和控制参数初始值开始，不断对解进行产生新解->计算目标函数差->接收/舍弃的迭代，并逐步衰减控制参数的值，直到算法终止得到近似最优解，是一种启发式随机搜索过程

### 求解

1. 初始化初始值 T 和初始解状态 S；
2. 产生新解 S'；
3. 计算增量 Δt′=C(S′)-C(S)，其中 C(S)为评价函数；
4. 若 Δt′<0 则接受 S′作为新的当前解，否则以概率 exp(-Δt′/T)接受 S′作为新的当前解；
5. 如果满足终止条件则输出当前解作为最优解，结束程序，反之 T 逐渐减小，且 T->0，继续循环。

### 参数控制问题

初始值 T：会影响算法全局搜索性能。初始值大则搜索到全局最优解可能性大，但时间长；反之可能性小，时间短

退火速度：会影响算法全局搜索性能。在同一温度下的充分退火对搜索到最优解是必要的

温度管理：T(t + 1) ＝ k × T(t)， k 略小于 1.00，t 为降温次数

## 搜索算法

### 定义

穷举问题的可能情况从而求出解

### 求解

#### 回溯算法

先根遍历构造解答树，走不通就回头

#### DFS 与 BFS

DFS 先搜索子节点，BFS 先搜索兄弟节点

### 优化

#### 双向广度搜索

从正反两个方向进行广度搜索，且先走数目较少的一方，提高搜索速度

#### 分支定界

对于搜索出的节点给出一个预期值，若预期值不如已获得的最优值则将这个节点以及子节点删去

#### A\*算法

估价函数 f = g + h，g 为到达当前节点的耗费，h 为从当前节点到达目标节点耗费的估计，需要满足条件：h≤ 实际的从当前节点到达目标节点的最小耗费 h\*，f↑

每次扩展当前节点中 f 值最小的一个，如果扩展出来的节点与已扩展的节点重复，则删去这个节点；如果与待扩展节点重复，如果这个节点的估价函数值较小，则用其代替原节点

**优化**：出现数据溢出时从原节点中取出若干 f 较小的节点，然后放弃剩余原节点

## 贪婪算法

### 定义

逐步构造最优解，最终得到问题的解

### 求解

在每个阶段，都作出一个看上去最优的决策（在一定的标准下），决策一旦作出，就不可再更改，作出贪婪决策的依据称为贪婪准则

## 遗传算法

### 定义

模拟自然进化过程搜索最优解

### Matlab 求解

**模型**：编码->初始化种群->评估种群中个体适应度->选择->交叉->变异->演化并再次评估

1. 随机产生种群；
2. 根据策略判断个体的适应度，是否符合优化准则，若符合，输出最佳个体及其最优解，结束，否则，进行下一步；
3. 依据适应度选择父母，适应度高的个体被选中的概率高，适应度低的个体被淘汰；
4. 用父母的染色体按照一定的方法进行交叉，生成子代；
5. 对子代染色体进行变异，产生新一代种群，重复 2，直到最优解产生

```matlab
% 定义目标函数
function y = simple_fitness(x)

y = x*sin(10*pi*x)+2

end
```

```matlab
ObjectiveFunction = @simple_fitness;
nvars = 1; % 变量个数
LB = [-1] % 定义域下限
UB = [2] % 定义域上限

[x,fval] = ga(ObjectiveFunction,nvars,[],[],[],[],LB,UB)
% ga函数即为遗传算法，默认求出全局的最小值取值点x与最小值fval，改成-即求最大值
```

## 组合算法

### 定义

属于算法分析学，包括单纯形法和排序与检索

### 求解

#### 单纯形法

一种线性规划算法，前面已经介绍

#### 内部排序

插入排序（直接插入排序、折半插入排序、表插入排序）、交换排序（冒泡排序、一趟快速排序、快速排序）、选择排序（简单选择排序、堆排序）、归并排序、基数排序（多关键词排序、链式基数排序）

**时间复杂度**：

O(nlogn)：快速排序、堆排序和归并排序，其中以快速排序为最好；
O(n2)：直接插入排序、起泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此；
O(n)：基数排序。

**空间复杂度**：

O(1)：直接插入、起泡和简单选择、堆排序；
O(logn)：快速排序；
O(n)：归并排序；
O(rd)：链式基数排序。

#### 外部排序

磁带排序（顺序存取）、磁盘排序（直接存取）

1. 按可用内存大小，利用内部排序的方法，构造若干(记录的)有序子序列，通常称外存中这些记录有序子序列为“归并段”;
2. 通过“归并”，逐步扩大(记录的)有序子序列的长度，直至外存中整个记录序列按关键字有序为止。

并行排序：利用多台处理机（并行机）进行的排序，用于提高速度

#### 图与网络优化算法

求最小生成树的 Kruskal 算法、求最短路径的 Dijkstra 算法、求二部图最大匹配（指派问题）的匈牙利算法、求网络最大流和最小割的标号算法

#### 贪婪算法、穷举算法、分支限界法、DP

前面已经介绍
